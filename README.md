# Voting dApp

- [Voting dApp](#voting-dapp)
  - [Project description](#project-description)
  - [Repo structure](#repo-structure)
    - [nctl-docker](#nctl-docker)
    - [node-proxy](#node-proxy)
    - [testnet-keys](#testnet-keys)
    - [voting](#voting)
    - [voting-frontend](#voting-frontend)
  - [Contract on-chain and backend](#contract-on-chain-and-backend)
    - [Odra framework](#odra-framework)
      - [Odra pros](#odra-pros)
      - [Odra cons](#odra-cons)
  - [Contract frontend](#contract-frontend)

## Project description

This is example of full-stack project that implements some simple DAO contract. On-chain part is written with [Odra framework](https://odra.dev/docs/) that greatly simplifies contract writing, but also have some drawbacks (see [Contract on-chain and backend section](#contract-on-chain-and-backend)). User interaction happens through React application.

After main contract is deployed on-chain users can:

- Create new proposals. Currently, proposal consists of some description and 3d party arbitrary contract that can be called. On-chain and backend parts do not have any limits on what contract endpoint with what arguments can be called. But frontend UI currently have some limitations on what arguments can be passed to the contract endpoint. For more details see [Contract frontend section](#contract-frontend).
- Vote on created proposals. There are no restrictions at the moment and anybody can vote, but only one time per proposal. The initial idea was to allow user to vote according their stake represented by some ERC20 standard token, but it was omitted due to development time limitations.
- Close voting. No limits here currently again - anybody can close voting. But if proposal receives majority of "YES" votes, contract inside proposal will be executed, and the one who closes voting will need to pay gas price for whatever was executed there.

## Repo structure

### nctl-docker

Docker image to start local private network. There are `Make` commands available to start, stop, restart network and to copy predefined funded keys. Keys are copied already and into [nctl-docker/users](./nctl-docker/users/) directory, but if node version changes old keys may stop working. Node version set through [docker-compose file](./nctl-docker/docker-compose.yaml).

### node-proxy

TypeScript proxy server. Casper nodes require CORS. This proxy server solves the issue proxying requests from browser frontend. For more details see [Contract frontend section](#contract-frontend).

### testnet-keys

Funded keys on `testnet` network. Can be imported to `Casper Wallet` browser extension.

### voting

Contains two Rust packages:
- Smart DAO smart contract and deployer for it implemented using Odra framework
- Query service to query network global state

For more details see [Contract on-chain and backend section](#contract-on-chain-and-backend)

### voting-frontend

React app with basic UI that allows to create new proposals, vote on them and close them. [Contract frontend section](#contract-on-chain-and-backend).

## Contract on-chain and backend

Smart contract is implemented using [Odra framework](https://odra.dev/docs/). Odra abstracts away all low-level Casper code and generates query layer for on-chain global state related to the contract and also generates `Deployers` that can contract endpoints on real network.

### Odra framework

#### Odra pros

- A lot of low-level code is abstracted away
- Code looks more like plain Rust: contract is `struct` and contract endpoints are methods of `impl`. All storage interactions also hidden behind `struct` fields that mics regular types like variables of type `T`, lists, maps and etc..
- Tests are kept in the same `.rs` file as in regular Rust code, not in the separate package like in `vanilla` casper examples
- `Deployer` is generated for each contract. It gives simple abstraction for calling contract entry points - they are called just as regular methods via dot-notation. `livenet` feature allows to deploy and call contract on real network

#### Odra cons

Names of `NamedKeys` and `Dictionary` keys used to store data on-chain are not transparent. With low-level Casper code contract author defines set of constants for `NamedKeys` names and name of the `Dictionaries` he uses. All that names can be be found in the source code and checked. Odra from the other sie stores all contract's is single `Dictionary` (currently it is called `state`).

At the moment, if contract `struct` has `Variable`, the value is stored inside this `state` dictionary, and name for the key is generated by concatenating contract name with variable name and then hashing it. If one contract ha another contract as its field, then both contract names are concatenated and then variable name added to them and everything hashed. If something is stored in the `Mapping`, then name of the field that sued for `Mapping` in contract `struct` becomes "dictionary" name, and when something is added into `Mapping`, contract name is concatenated with `Mapping` field name ("dictionary" name) and concatenated with key name that user uses to store data in `Mapping`. All this then hashed and resulted value used to store data in `state` `Dictionary` (so it sort of like Redis keys namespaces, but also hashed).

The problem is that algorithm of keys generation is hidden from the contract developer and is subject to change. It makes querying data from chain less straightforward. Although it is possible to recreate keys creation in, say, React application (and it was tested and works), algorithm of key creation may change in future (Odra devs also warns about it).

From the other side, it is possible to use `getters` in contract `impl` to read values from contract `struct` field. Odra will generate `Deployer` for each contract and this methods will be available through the contract reference that `Deployer` returns after contract initialization. Those getters are just wrappers around JSON RPC requests to the node and does not require any gas to be called. Now the question is - how to get those getters available for front-end.

With current Odra version `0.4.0` there is no out-of-the box solution. Current solution was to write simple [web-service](./voting/query-service/) that provides REST API on top of contract "getters".

Other possible variants:
- Emit events when contract state is changed. Those events can be indexed by some custom indexer and then front-end can query this index. Seems like [casper.cloud](https://cspr.cloud/) can become a general solution for it (it is probably the end result of development of [casper-dao-middleware](https://github.com/make-software/casper-dao-middleware)).
- In release `0.6.0` Odra team plans to add [WASM client](https://github.com/odradev/odra/issues/202) which will be auto-generated from the contract getters (or maybe straight from struct fields) and can be run in browser.

## Contract frontend